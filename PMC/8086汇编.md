# 汇编基础

## 寄存器

### 概图

![img](8086汇编/2012110700571289.gif)

### 通用寄存器

8086CPU有8个 **通用寄存器**，每一个寄存器都有自己的名称：

- **AX** 累加寄存器 accumulator register（分为 **AH / AL**）.
- **BX** 基址寄存器 base address register （分为 **BH / BL**）.
- **CX** 计数寄存器 count register（分为 **CH / CL** ）.
- **DX** 数据寄存器 data register （分为 **DH / DL**）.
- **SI** 源变址寄存器 source index register.
- **DI** 目的变址寄存器 destination index register.
- **BP** 基址指针寄存器 base pointer.
- **SP** 堆栈寄存器 stack pointer.

### 段寄存器

- **CS** 代码段寄存器，用来存放当前正在运行的指令
- **DS** 数据段寄存器，用来存放当前运行程序所用的数据
- **ES** 附加段寄存器，由程序员决定用途
- **SS** 堆栈段寄存器，指出堆栈所在区域

默认下，**BX** **SI** 及 **DI** 与 **DS**协同工作，**BP SP**与 **SS** 寄存器协同工作。

![img](8086汇编/2012110701033366.gif)

其余的通用寄存器不能形成有效地址！同样，尽管**BX**可以形成有效地址，但是**BH BL**不能。

### 控制寄存器

- **IP** 指令指针寄存器 instruction pointer
- **Flags Register** 状态标志寄存器

**IP** 始终同**CS** 协同工作，指出当前执行的指令。

**Flags Register** 完成一次数学运算后，由CPU自动修改，通过它可以得到当前结果类型，也可以作为跳转语句条件。通常你无法直接访问它们。

## 寻址方式

### 概要

<img src="8086汇编/1540089150049.png" style="zoom:70%">

  **d8** - 表示８位偏移量

**d16** - 表示16位偏移量  

![img](8086汇编/2012110701033366.gif)

只有这些寄存器可以放入方括号中（作为内存指针）**BX, SI, DI, BP**  

### MOV

- 源和目的必须是同样大小，要么都是字节要么都是字

操作类型如下:

```asm
MOV REG, memory
MOV memory, REG
MOV REG, REG
MOV memory, immediate
MOV REG, immediate
```

> **REG**: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.
> **memory**: [BX], [BX+SI+7],变量, 等等
> **immediate**: 5, -24, 3Fh, 10001101b, 等等

只支持如下段寄存器:

```asm
MOV SREG, memory
MOV memory, SREG
MOV REG, SREG
MOV SREG, REG
```

> **SREG**: DS, ES, SS, 注意 CS 只能作操作源
> **REG**: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.
> **memory**: [BX], [BX+SI+7], variable, 等等  

**MOV**指令不能用来设置**CS**和**IP**寄存器的值

## 量

### 变量

```asm
#MAKE_COM#
ORG 100h
MOV AL, var1
MOV BX, var2
RET    ; stops the program.
VAR1 DB 7 ;7 7h 10b ? (not sure)
var2 DW 1234h ;db(byte 8bits),dw(word 16bits)
```

### 数组

```asm
a DB 48h, 65h, 6Ch, 6Ch, 6Fh, 00h
b DB 'Hello', 0 
c DW 5 DUP(9) ;the same as: c DB 9, 9, 9, 9, 9 
d DB 5 DUP(1, 2)
;the same as:d DB 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 
```

如果需要存放超过255或者小于－128的数值，使用**DW**来代替 **DB**。但是**DW**不能用于声明字符串。**DUP**命令展开后不能超过1020个字符，如果需要声明请将它们分成两行（这样，内存中得到的仍然是一个大数组）。

### 取得变量地址

```asm
BYTE PTR [BX] ;按字节访问
WORD PTR [BX] ;按字访问
```

```asm
ORG 100h
MOV    AL, VAR1      ; 将变量var1的数值放入al以便检查
LEA    BX, VAR1              ; 将var1的地址存入 BX.
;or MOV    BX, OFFSET VAR1
MOV    BYTE PTR [BX], 44h    ; 修改变量var1的内容
MOV    AL, VAR1              ; 将变量VAR1的数值放入AL以便检查
RET
VAR1   DB  22h
END
```

### 常量

```asm
k EQU 5
MOV AX, k
```

## 中断

[参考](http://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html)

## 算逻指令

### 1. **ADD**, **SUB**,**CMP**, **AND**, **TEST**, **OR**, **XOR**

支持如下操作数:

```asm
REG, memory
memory, REG
REG, REG
memory, immediate
REG, immediate
```

> **REG（寄存器）**: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.
> **memory（内存）**: [BX], [BX+SI+7], 变量,等等...
> **immediate（立即数）**: 5, -24, 3Fh, 10001101b, 等等...

**CMP**和**TEST**指令只影响标志位，并不返回数值（这两条指令是用来在程序运行中判断的）上述指令只影响如下标志位：**CF**, **ZF**, **SF**, **OF**, **PF**, **AF**.

### 2. **MUL**, **IMUL**, **DIV**, **IDIV**

支持如下操作数:

```asm
REG
memory
```

> **REG（寄存器）**: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.
> **memory（内存）**: [BX], [BX+SI+7], variable, etc...

**MUL** and **IMUL** 指令只影响 **CF**, **OF**标志位。
运算后如果结果超出范围，这些标记位置**1**，如果没有超过范围，置**0**

**DIV** 和 **IDIV** 指令对于标志位无影响

> - **MUL** \- **无**符号乘:
>   当操作数是**字节**时: AX = AL * 操作数.
>   当操作数是**字**时: (DX AX) = AX * 操作数.
> - **IMUL** \- **有**符号乘法:
>   当操作数是**字节**时: AX = AL * 操作数.
>   当操作数是**字**时: (DX AX) = AX *  操作数.
> - **DIV** - **无**符号除法:
>   当操作数是**字节**时: AL = AX / 操作数, AH = 余数（取模后的余数).
>   当操作数是**字**时: AX = (DX AX) / 操作数, DX = 余数（取模后的余数）
> - **IDIV** - **有**符号除法:
>   当操作数是**字节**时: AL = AX / 操作数, AH =余数（取模后的余数）
>   当操作数是**字**时: AX = (DX AX) / 操作数 DX = 余数（取模后的余数） .

  ### 3.  **INC**, **DEC**, **NOT**, **NEG**

支持如下操作数:

```asm
REG
memory
```

> **REG（寄存器）**: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.
> **memory（内存）**: [BX], [BX+SI+7], variable, etc...

**INC**, **DEC** 指令只影响如下标志位: **ZF**, **SF**, **OF**, **PF**, **AF**.
**NOT** 指令不影响任何标志位(取反)
**NEG** 指令只影响如下操作位： **CF**, **ZF**, **SF**, **OF**, **PF**, **AF**.  （取反加一）

### 4. SAL, SHL, SHR, SAR,ROL,ROR,RCL,RCR

<img src="8086汇编/1540104739802.png" style="zoom:60%">

<img src="8086汇编/1540104799306.png" style="zoom:60%">

## 其他指令

### 跳转指令

<img src="8086汇编/1540103453241.png" style="zoom:60%">

<img src="8086汇编/1540114640621.png" style="zoom:60%">

### 堆栈指令

<img src="8086汇编/1540106062283.png" style="zoom:60%">

### 循环控制

```asm
LOOP   short-label ; Loop 
 	; DEC CX 
 	; JNZ  short-label 
JCXZ    short-label ; Jump if register CX=0	 
	; TEST CX, CX 
	; JZ short-label
```

## 程序结构

### 总结构

```asm
; 8086 Assembly Program “Hello.asm”
;------------------堆栈段------------------
;[名字]   伪指令 [参数] 
STACK	SEGMENT 
		DB   256 DUP(0)
STACK 	ENDS
;------------------数据段------------------
DATA	SEGMENT 
HELLO	DB  0DH,0AH,"Hello World!",0DH,0AH, "$" 
DATA 	ENDS
;------------------代码段------------------
CODE	SEGMENT 
;伪指令：段假设 - ASSUME 
		ASSUME CS:CODE, DS:DATA, SS:STACK 
;伪指令：过程定义 - PROC、ENDP 
;FAR：远过程，可以段间调用 
;NEAR：近过程，默认类型(可以省略)，仅段内调用
MAIN	PROC	FAR 
;指令语句格式
;[标号:]  操作码助记符 [操作数]
START: 	PUSH	DS ; 保存返回地址 
		XOR		AX,AX 
		PUSH	AX 
		MOV		AX, DATA    ; 初始化DS 
		MOV 	DS, AX 
		LEA 	DX, HELLO  ; 显示字符串 
		MOV 	AH, 09H 
		INT 	21H 
		RET 			; 返回DOS 
MAIN ENDP 
CODE ENDS 
;------------------结束------------------
;伪指令：汇编结束
;如果是主模块，END后可指定程序入口地址，又称启动地址 
	END START
```

### 分支

编程实现：将AL中的低4位，转换成十六进制数 的ASCII码，保存在AL中 – 0\~9和A~F的ASCII码分别为30H ~ 39H和41H ~ 46H)

```asm
	AND AL, 0FH 
	CMP AL, 9 
	JA A2F 
	OR AL, 30H 
	JMP   Done 
A2F: ADD AL, 37H 
Done: 
```

if-else

```asm
;if(AL== 'Y')
	CMP AL,"Y"
	JNE else_part
	...
	JMP end_if
else_part:
	...
end_if:
	...
```

复合条件

```asm
;情形一
;if(AL>='0' && AL <= '9')
	CMP AL,30h
	JB end_if
	CMP AL,'9'
	JA end_if
	...
endif:
	...
	
;情形二
;if(AX<-10 || AX >10)
	CMP AX,-10
	JL then_part
	CMP AX,10
	JLE end_if
then_part:
	...
end_if:
	...
```

### 循环结构

编程实现：将AX 中的无符号二进制 数，转换成十六进 制数的ASCII码串， 保存到以BX为指针 的存储器中(大端序 存储) – 0\~9和A~F的ASCII 码分别为30H ~ 39H 和41H ~ 46H 

```asm
;  初始化
		MOV CX, 0404H    ; 设置移位次数和循环次数  
;循环主体 
HNEXT:	ROL AX, CL ; 高4位移到低4位 
		MOV DX, AX ; 保护原始数据 
		AND AL, 0FH ; 低4位转换为 
		OR AL, 30H ; ASCII码 
		CMP AL, 3AH 
		JB SAVE 
		ADD AL, 07H 
SAVE: 	MOV [BX], AL ; 保存转换结果 
;  循环调整 
		INC BX ; 修改存储指针 
		MOV AX, DX ; 恢复原始数据 
		DEC CH ; 修改循环次数 
; 循环控制 
		JNZ HNEXT ; 已达4次？
```

累计while

```asm
;unsigned int  sum = 0, i = 1; 
;while ( i <= 100 ) { sum = sum + i; i++; }
;一种实现
		MOV  AX, 0      ; sum = 0 
		MOV  CX, 1 ; i = 1 
Next:   CMP  CX, 100 
		JA    Done          ; i > 100? 
		ADD  AX, CX    ; sum + i 
		INC   CX ; i + 1 
		JMP Next 
Done: 	...

;另一种实现
		XOR  AX, AX    ; sum = 0 
		MOV CX, 1 ; i = 1 
		JMP  Tst  
Next:	ADD  AX, CX    ; sum + i 
		INC   CX ; i + 1 
		Tst: CMP CX, 100 
		JBE Next ; i ≤100? 
Done: 	...
```

do-while

```asm
;unsigned int sum = 0, i = 1; 
;do  { sum = sum + i; i++; } while ( i <= 100 );
;一种实现
		XOR  AX, AX    ; sum = 0 
		MOV CX, 1 ; i = 1 
Next:  	ADD AX, CX ; sum + i 
		INC   CX ; i + 1 
		CMP CX, 100 
		JBE Next ; i ≤100? 
Done: 	...

;优化实现
;unsigned int sum = 0, i = 100;
;do  { sum = sum + i; i--; } while ( i != 0 );
		XOR  AX, AX    ; sum = 0 
		MOV CX, 100    ; i = 100 
Next: 	ADD AX, CX ; sum + i 
		DEC   CX ; i - 1 
		JNZ Next ; i≠0? 
Done: 	...
```

## 程序调用

### 子程序调用

案例求和

```C
int  total (int *arr, int n) {
    int  result = 0; 
    for( ; n>=0; n--) 
        result += arr [n] ; 
    return  result; 
} 

Sum = total(Array, 100);
```

利用寄存器参数传递

```asm
; 主程序段 
...
	LEA BX, ARRAY ; 设置入口参数 
	MOV CX, 100 
	CALL TOTAL ; 调用求和子程序 
	MOV SUM, AX ; 保存求和结果 
...
; 求和子程序 
; 入 口 参 数: BX－数组指针 ; CX－数组项数 
; 出 口 参 数: AX－数组和 
TOTAL 	PROC  NEAR 
		XOR AX, AX 
NEXT: 	ADD AX, [BX] 
		ADD BX, 2 
		LOOP   NEXT 
		RET 
TOTAL ENDP
```

利用堆栈参数传递

```asm
; 主程序段 
	...
	LEA  SI, ARRAY  
	PUSH SI ; 设置入口参数
	MOV CX, 100 
	CALL TOTAL ; 调用求和子程序 
	POP SUM ; 保存求和结果 
	...
; 求和子程序 
; 入 口 参 数: 堆栈－数组地址 
; 			  CX－数组项数 
; 出 口 参 数: 堆栈－数组和 
TOTAL: 	PUSH BP 
		MOV BP, SP 
		PUSH AX 
		PUSH BX 
		XOR AX, AX 
		MOV BX, [BP+4] 
NEXT:  	ADD AX, [BX] 
		ADD BX, 2 
		LOOP NEXT 
		MOV [BP+4], AX 
		POP BX 
		POP AX 
		POP BP 
		RET
```

<img src="8086汇编/1540107660852.png" style="zoom:60%">

### 中断

#### 输入

```asm
INT 21H
```

##### 带回显的字符输入 

- 功能：等待从键盘输入一按键，并显示在屏幕上 

- 入口参数：AH = 1 

- 出口参数：AL = 按键的ASCII码 

##### 不带回显的字符输入 

- 除AH=8和不显示键入的字符外，其他同上

##### 带回显的字符串输入 

- 功能：等待从键盘输入以回车结束的一串字符，并存 入设定的缓冲区，同时显示在屏幕上 
- 入口参数 ▪ AH = 0AH, DS : DX = 缓冲区首址, 其中 [DS : DX] = 缓冲区大小 (1~255) 
-  出口参数 ▪ [DS : (DX+1)] = 输入字符数(除回车外), 输入的字符 串从DS : (DX+2)开始存

#### 输出

```asm
INT 21H
```

##### 字符输出 

- 功能：在屏幕上显示一个字符 
- 入口参数：AH = 2, DL = 待显示ASCII码字符 
- 出口参数：无 

##### 字符串输出 

- 功能：在屏幕上显示一个字符串 
- 入口参数：AH = 9, DS:DX =以‘$’结束的ASCII码字符串的起始地址 
- 出口参数：无

## 简化段

```asm
.code
.data
.stack 128
.startup;自动初始化DS,SS,SP
.exit
```



## 附录

### 状态标记寄存器

![img](8086汇编/2012110701534779.gif)

> - **进位标志 Carry Flag (CF)** - 出现无符号（unsigned overflow）溢出该位设置成**1**。例如，计算 **255+1**（结果超出0...255）。没有溢出时该位为**0**。
> - **零标志 Zero Flag (ZF)** - 当结果为 **0** 时设置为**1**，结果不为 **0** 时设置为**0**。
> - **符号标志 Sign Flag (SF)** -  结果为**负**置1，结果为**正**置为0。事实上该位对于结果特别重要。
> - **溢出标志 Overflow Flag (OF)** -  当出现有符号数溢出设置为1。例如，计算**100+50**（结果超出－128－127的范围）。
> - **奇偶标志 Parity Flag (PF)** - 当结果操作数中1的个数为偶时置**1**，否则为**0**注意，如果结果是一个字，该标志只指示低8位。
> - **辅助进位标志 Auxiliary Flag (AF)** -  低4位向上进位时置**1**，否则为**0**（记录运算时第3位（半个字节）产生的进位值。例如，执行加法指令时，最高有效位有进位时置1，否则置0
> - **中断标志 Interrupt enable Flag (IF)** - 当cpu容许中断时为**1**，否则为**0** 
> - **Direction Flag (DF)** - 方向标志，在串处理指令中控制处理信息的方向用。当**DF**为1时，每次操作后使变址寄存器SI和DI减量，这样就使串处理从高地址向低地址方向处理。当**DF**为0时，则使SI和DI增量，使串处理从低地址向高地址方向处理。

# 汇编实验



